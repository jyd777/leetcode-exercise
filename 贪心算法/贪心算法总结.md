## 贪心算法的核心思想

贪心算法是一种在每一步选择中都采取当前状态下最好或最优的选择，从而希望导致结果是最好或最优的算法策略。

## 贪心技巧总结

### 1. **维护最优状态**
- **买卖股票**：维护最低买入价格 `minPrice`
- **跳跃游戏**：维护最远可达距离 `maxReach`
- **跳跃游戏II**：维护当前跳跃边界 `currentEnd` 和下一步边界 `nextEnd`
- **划分字母区间**：维护当前片段结束位置 `end`

### 2. **局部最优选择**
- **买卖股票**：对于每个价格，选择与最低价格的差值作为潜在利润
- **跳跃游戏**：对于每个位置，选择能够到达的最远距离
- **跳跃游戏II**：在每一步跳跃中，选择能够到达最远距离的位置
- **划分字母区间**：对于每个字母，选择其最后出现位置作为片段边界

### 3. **无后效性**
- 贪心算法的关键特征：当前决策不会影响之前的状态
- 每次选择都是基于当前最优，不需要考虑历史路径

### 4. **边界条件处理**
- **提前返回**：当已经达到目标时，立即返回结果
- **边界检查**：确保不会越界或出现无效状态

## 贪心算法的通用模板

```cpp
// 贪心算法通用模板
class Solution {
public:
    ReturnType solve(InputType input) {
        // 1. 初始化最优状态变量
        OptimalState optimalState = initialValue;
        
        // 2. 遍历输入数据
        for (auto item : input) {
            // 3. 更新最优状态（局部最优选择）
            optimalState = updateOptimalState(optimalState, item);
            
            // 4. 检查是否达到目标（提前返回）
            if (isTargetReached(optimalState)) {
                return getResult(optimalState);
            }
        }
        
        // 5. 返回最终结果
        return getFinalResult(optimalState);
    }
};
```

## 贪心算法的适用场景

1. **最优化问题**：求最大值、最小值、最优解
2. **区间问题**：需要处理范围或边界的问题
3. **调度问题**：需要合理安排顺序的问题
4. **选择问题**：需要在多个选择中做出最优决策

## 贪心算法的验证方法

1. **反证法**：假设贪心选择不是最优的，然后证明矛盾
2. **数学归纳法**：证明贪心选择在每一步都是最优的
3. **交换论证**：证明任何非贪心选择都可以通过交换变成贪心选择

## 注意事项

1. **贪心选择性质**：必须证明贪心选择是安全的
2. **最优子结构**：问题的最优解包含子问题的最优解
3. **局部最优不一定全局最优**：需要仔细分析问题特性

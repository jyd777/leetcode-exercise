# 跳跃游戏 II

给定一个长度为 `n` 的 **0 索引**整数数组 `nums`。初始位置为 `nums[0]`。

每个元素 `nums[i]` 表示从索引 `i` 向后跳转的最大长度。换句话说，如果你在 `nums[i]` 处，你可以跳转到任意 `nums[i + j]` 处:

- `0 <= j <= nums[i]` 
- `i + j < n`

返回到达 `nums[n - 1]` 的最小跳跃次数。生成的测试用例可以到达 `nums[n - 1]`。

 

**示例 1:**

```
输入: nums = [2,3,1,1,4]
输出: 2
解释: 跳到最后一个位置的最小跳跃数是 2。
     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。
```

**示例 2:**

```
输入: nums = [2,3,0,1,4]
输出: 2
```

 

**提示:**

- `1 <= nums.length <= 104`
- `0 <= nums[i] <= 1000`
- 题目保证可以到达 `nums[n-1]`



## 贪心算法解法

贪心思想：在每一步跳跃中，选择能够到达最远距离的位置作为下一步的起点。

```cpp
class Solution {
public:
    int jump(vector<int>& nums) {
        int n = nums.size();
        if(n<=1)
            return 0;
        int jumps = 0;// 跳跃次数
        int cur_end = 0;// 当前跳跃能到达的最远位置
        int next_end = 0;// 下一步跳跃能到达的最远位置
        for(int i=0;i<n;i++){
            // 更新下一步能到达的最远位置
            next_end = max(next_end, i+nums[i]);
            // 如果到达了当前跳跃的边界，则可以跳跃，而且更新cur_end为next_end
            if(i == cur_end){
                jumps++;
                cur_end = next_end;
                // 判断是否已经到达终点
                if(cur_end>=n-1)
                    break;
            }
        }
        return jumps;
    }
};
```

**时间复杂度：** O(n)

**空间复杂度：** O(1)

**贪心策略解释：**
1. **维护跳跃边界**：`currentEnd` 表示当前跳跃能到达的最远位置
2. **更新下一步边界**：`nextEnd` 表示下一步跳跃能到达的最远位置
3. **跳跃决策**：当到达当前边界时，必须跳跃，并更新边界
4. **提前返回**：如果已经可以到达终点，直接返回

**为什么这样是贪心的：**
- 在每一步跳跃中，选择能够到达最远距离的位置
- 不需要考虑具体的跳跃路径，只关心跳跃次数
- 每次跳跃都是基于当前最优选择

**示例分析：**
- 对于 `[2,3,1,1,4]`
- 遍历过程：
  - i=0: nextEnd=2, currentEnd=0, 需要跳跃，jumps=1, currentEnd=2
  - i=1: nextEnd=4, currentEnd=2, 到达边界，jumps=2, currentEnd=4
  - 由于currentEnd>=4，返回2
# 划分字母区间

给你一个字符串 `s` 。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。例如，字符串 `"ababcc"` 能够被分为 `["abab", "cc"]`，但类似 `["aba", "bcc"]` 或 `["ab", "ab", "cc"]` 的划分是非法的。

注意，划分结果需要满足：将所有划分结果按顺序连接，得到的字符串仍然是 `s` 。

返回一个表示每个字符串片段的长度的列表。

 

**示例 1：**

```
输入：s = "ababcbacadefegdehijhklij"
输出：[9,7,8]
解释：
划分结果为 "ababcbaca"、"defegde"、"hijhklij" 。
每个字母最多出现在一个片段中。
像 "ababcbacadefegde", "hijhklij" 这样的划分是错误的，因为划分的片段数较少。 
```

**示例 2：**

```
输入：s = "eccbbbbdec"
输出：[10]
```

 

**提示：**

- `1 <= s.length <= 500`
- `s` 仅由小写英文字母组成

## 贪心算法解法

贪心思想：先统计每个字母的最后出现位置，然后遍历字符串，维护当前片段的结束位置。

```cpp
class Solution {
public:
    vector<int> partitionLabels(string s) {
        // 统计每个字母的最后出现位置
        vector<int> last_pos(26,-1);
        for(int i=0;i<s.length();i++)
            last_pos[s[i]-'a'] = i;
        // 基于每个字母最后出现的位置来确定片段
        vector<int> ret;
        int start = 0;// 当前片段的起始位置
        int end = 0;// 当前片段的结束位置
        for(int i=0;i<s.length();i++){
            // 更新当前片段结束位置
            end = max(end, last_pos[s[i]-'a']);
            // 如果当前位置等于结束位置，说明当前片段结束
            if(i == end){
                ret.push_back(end-start+1);
                start = i+1;
            }
        }
        return ret;
    }
};
```

**时间复杂度：** O(n)

**空间复杂度：** O(1) - 因为字母表大小固定为26

**贪心策略解释：**
1. **统计最后位置**：遍历字符串，记录每个字母的最后出现位置
2. **维护片段边界**：遍历时维护当前片段的结束位置
3. **划分片段**：当当前位置等于结束位置时，划分一个片段
4. **更新起始位置**：开始下一个片段的统计

**为什么这样是贪心的：**
- 对于每个字母，我们只关心它的最后出现位置
- 在遍历过程中，不断扩展当前片段的结束位置
- 当无法再扩展时，立即划分片段，这是局部最优选择

**示例分析：**
- 对于 `"ababcbacadefegdehijhklij"`
- 统计最后位置：a=8, b=5, c=7, d=14, e=15, f=11, g=13, h=19, i=22, j=23, k=20, l=21
- 遍历过程：
  - i=0: end=8 (a的最后位置)
  - i=1: end=8 (b的最后位置是5，但当前end已经是8)
  - ...
  - i=8: i==end，划分片段[0,8]，长度为9
  - 继续下一个片段...
# 最长回文子串

给你一个字符串 `s`，找到 `s` 中最长的 回文 子串。

 

**示例 1：**

```
输入：s = "babad"
输出："bab"
解释："aba" 同样是符合题意的答案。
```

**示例 2：**

```
输入：s = "cbbd"
输出："bb"
```

 

**提示：**

- `1 <= s.length <= 1000`
- `s` 仅由数字和英文字母组成



**状态定义：**

- `dp[i][j]`：表示子串 `s[i...j]` 是否为回文串

**状态转移方程：**

1. **基础情况**：
   - `dp[i][i] = true`（单个字符是回文串）
   - `dp[i][i+1] = (s[i] == s[i+1])`（两个相邻字符）

2. **一般情况**：
   - `dp[i][j] = (s[i] == s[j] && dp[i+1][j-1])`
   - 即：如果两端字符相同，且中间部分也是回文串，则整个子串是回文串

**算法步骤：**

1. **初始化**：所有单个字符都是回文串
2. **检查长度为2的子串**：相邻字符是否相同
3. **检查长度大于2的子串**：使用状态转移方程
4. **记录最长回文子串**：在遍历过程中记录最长回文子串的起始位置和长度

```cpp
class Solution {
public:
    string longestPalindrome(string s) {
        int n = s.length();
        if (n <= 1) return s;
        
        // dp[i][j] 表示 s[i...j] 是否为回文串
        vector<vector<bool>> dp(n, vector<bool>(n, false));

        // 初始化，每一个单独字符都是回文串
        for(int i=0;i<n;i++)
            dp[i][i] = true;
        int start = 0;  // 最长回文子串的起始位置
        int max_len = 1; // 最长回文子串的长度                
        // 检查长度为2的子串
        for(int i=0;i<n-1;i++)
            if(s[i]==s[i+1]){
                dp[i][i+1] = true;
                start = i;
                max_len = 2;
            }
        // 长度大于2的子串
        for(int len=3;len<=n;len++){
            for(int left=0;left<=n-len;left++){
                int right = left+len-1;
                if(s[left]==s[right] && dp[left+1][right-1]){
                    dp[left][right] = true;
                    if(len>max_len){
                        start = left;
                        max_len = len;
                    }
                }
                
            }
        }
        return s.substr(start,max_len);
    }
};
```

**复杂度：**

- 时间复杂度：O(n²)

- 空间复杂度：O(n²)
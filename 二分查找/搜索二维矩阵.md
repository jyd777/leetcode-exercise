# 搜索二维矩阵

给你一个满足下述两条属性的 `m x n` 整数矩阵：

- 每行中的整数从左到右按非严格递增顺序排列。
- 每行的第一个整数大于前一行的最后一个整数。

给你一个整数 `target` ，如果 `target` 在矩阵中，返回 `true` ；否则，返回 `false` 。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/10/05/mat.jpg)

```
输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3
输出：true
```

**示例 2：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/25/mat2.jpg)

```
输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13
输出：false
```

 

**提示：**

- `m == matrix.length`
- `n == matrix[i].length`
- `1 <= m, n <= 100`
- `-104 <= matrix[i][j], target <= 104`



**方法一：先找行，再找列**

```cpp
class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        // 先确定在哪一行
        int row = 0;
        while(row < matrix.size()-1 && matrix[row+1][0]<=target)
            row++;
        // 再确认在这个一行的哪一个位置
        if(row >= matrix.size())
            return false;
        int col = search(matrix[row], target, 0, matrix[0].size()-1);
        if(col >= matrix[0].size())
            return false;
        return target == matrix[row][col];
    }
private:
    int search(vector<int>& num, int target, int left, int right){
        if(left>=right)
            return left;
        int mid = (left+right)/2;
        if(target == num[mid])
            return mid;
        else if (target > num[mid])
            return search(num, target, mid+1, right);
        return search(num, target, left, mid);
    }
};
```



**方法二：把整个矩阵看作是一维数组，进行二分查找**

```cpp
class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        // 把整个矩阵看作是一维数组，进行二分查找
        if(matrix.empty() || matrix[0].empty())
            return false;
        int m = matrix.size(), n = matrix[0].size();
        int left = 0, right = m*n-1;
        while(left<=right){
            int mid = (left+right)/2;
            int row = mid/n;
            int col = mid%n;
            if(matrix[row][col] == target)
                return true;
            else if(matrix[row][col] < target)
                left = mid+1;
            else
                right = mid-1;
        }
        return false;
    }
};
```


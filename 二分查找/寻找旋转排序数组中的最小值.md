# 寻找旋转排序数组中的最小值

已知一个长度为 `n` 的数组，预先按照升序排列，经由 `1` 到 `n` 次 **旋转** 后，得到输入数组。例如，原数组 `nums = [0,1,2,4,5,6,7]` 在变化后可能得到：

- 若旋转 `4` 次，则可以得到 `[4,5,6,7,0,1,2]`
- 若旋转 `7` 次，则可以得到 `[0,1,2,4,5,6,7]`

注意，数组 `[a[0], a[1], a[2], ..., a[n-1]]` **旋转一次** 的结果为数组 `[a[n-1], a[0], a[1], a[2], ..., a[n-2]]` 。

给你一个元素值 **互不相同** 的数组 `nums` ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 **最小元素** 。

你必须设计一个时间复杂度为 `O(log n)` 的算法解决此问题。

 

**示例 1：**

```
输入：nums = [3,4,5,1,2]
输出：1
解释：原数组为 [1,2,3,4,5] ，旋转 3 次得到输入数组。
```

**示例 2：**

```
输入：nums = [4,5,6,7,0,1,2]
输出：0
解释：原数组为 [0,1,2,4,5,6,7] ，旋转 4 次得到输入数组。
```

**示例 3：**

```
输入：nums = [11,13,15,17]
输出：11
解释：原数组为 [11,13,15,17] ，旋转 4 次得到输入数组。
```

 

**提示：**

- `n == nums.length`
- `1 <= n <= 5000`
- `-5000 <= nums[i] <= 5000`
- `nums` 中的所有整数 **互不相同**
- `nums` 原来是一个升序排序的数组，并进行了 `1` 至 `n` 次旋转

## 解决方案

```cpp
class Solution {
public:
    int findMin(vector<int>& nums) {
        int left = 0, right = nums.size()-1;
        // 用二分查找的思路去找最小值
        // 因为在旋转后，最小值位于中间，在最小值的左边是升序，在最小值的右边也是升序
        // 而右半部分的最大值也就是右边界一定是小于左半部分的任何一个值的
        // 因为我们是左右范围逐个缩小，直到定位到最小值
        // 而因为我们每次是更新左边界，所以最后其实是left指向最小值（即第二个升序的开头）
        // 所以我们需要把nums[mid]和nums[right]比较
        // 因为右边界一定是在第二个升序，而左边界在最后一刻会来到第二个升序，如果此时和左边界比较，就会得到最小值在mid右侧的的错误结论
        while(left< right){
            int mid = (left+right)/2;
            if(nums[mid] < nums[right])
                // 最小值在左半部分
                right = mid;
            else
                left = mid+1;
        }
        return nums[left];
    }
};
```

## 算法思路

1. **二分查找**：使用左闭右开区间 `[left, right)`
2. **比较策略**：
   - 比较中间元素 `nums[mid]` 和右边界元素 `nums[right]`
   - 如果 `nums[mid] > nums[right]`，说明最小值在右半部分
   - 如果 `nums[mid] < nums[right]`，说明最小值在左半部分（包括中间元素）

3. **终止条件**：当 `left == right` 时，找到最小值

## 关键点分析

1. **旋转数组特性**：
   - 旋转后的数组可以分成两个有序部分
   - 最小值总是位于第二个有序部分的开始位置

2. **比较策略的选择**：
   - 与右边界比较比与左边界比较更可靠
   - 因为右边界总是属于第二个有序部分

3. **区间更新**：
   - 当 `nums[mid] > nums[right]` 时，最小值在右半部分，`left = mid + 1`
   - 当 `nums[mid] < nums[right]` 时，最小值在左半部分，`right = mid`

## 示例分析

对于 `nums = [3,4,5,1,2]`：

1. 初始：`left = 0, right = 4`
2. `mid = 2, nums[2] = 5, nums[4] = 2`
3. `nums[2] = 5 > nums[4] = 2`，最小值在右半部分
4. `left = 3, right = 4`
5. `mid = 3, nums[3] = 1, nums[4] = 2`
6. `nums[3] = 1 < nums[4] = 2`，最小值在左半部分
7. `left = 3, right = 3`
8. 找到最小值 `nums[3] = 1`

## 特殊情况处理

1. **数组未旋转**：算法仍然有效，会返回第一个元素
2. **单元素数组**：直接返回该元素
3. **两元素数组**：比较两个元素，返回较小的

## 时间复杂度

- 时间复杂度：O(log n)
- 空间复杂度：O(1)

## 为什么与右边界比较？

1. **可靠性**：右边界总是属于第二个有序部分，而左边界可能属于第一个有序部分
2. **简化逻辑**：只需要比较一个边界，不需要考虑左边界的情况
3. **避免边界问题**：与左边界比较时，需要考虑数组未旋转的特殊情况

好的，我来给你一个具体的例子来说明为什么与右边界比较比与左边界比较更可靠。

## 例子分析

让我们看一个具体的旋转数组：`nums = [4,5,6,7,0,1,2]`

### 情况1：与右边界比较（推荐方法）

```cpp
// 比较 nums[mid] 和 nums[right]
```

**第一次迭代：**
- `left = 0, right = 6, mid = 3`
- `nums[mid] = 7, nums[right] = 2`
- `nums[mid] = 7 > nums[right] = 2`，说明最小值在右半部分
- 更新：`left = 4, right = 6`

**第二次迭代：**
- `left = 4, right = 6, mid = 5`
- `nums[mid] = 1, nums[right] = 2`
- `nums[mid] = 1 < nums[right] = 2`，说明最小值在左半部分（包括中间元素）
- 更新：`left = 4, right = 5`

**第三次迭代：**
- `left = 4, right = 5, mid = 4`
- `nums[mid] = 0, nums[right] = 1`
- `nums[mid] = 0 < nums[right] = 1`，说明最小值在左半部分
- 更新：`left = 4, right = 4`

**找到最小值：** `nums[4] = 0`

### 情况2：与左边界比较（会有问题）

```cpp
// 比较 nums[mid] 和 nums[left]
```

**第一次迭代：**
- `left = 0, right = 6, mid = 3`
- `nums[mid] = 7, nums[left] = 4`
- `nums[mid] = 7 > nums[left] = 4`，说明左半部分有序，最小值在右半部分
- 更新：`left = 4, right = 6`

**第二次迭代：**
- `left = 4, right = 6, mid = 5`
- `nums[mid] = 1, nums[left] = 0`
- `nums[mid] = 1 > nums[left] = 0`，说明左半部分有序，最小值在右半部分
- 更新：`left = 6, right = 6`

**找到最小值：** `nums[6] = 2` ❌ **错误！**

## 问题分析

### 为什么与左边界比较会出错？

1. **左边界的不确定性**：
   - 左边界可能属于第一个有序部分，也可能属于第二个有序部分
   - 当 `nums[mid] > nums[left]` 时，我们无法确定最小值在哪里

2. **右边界的确定性**：
   - 右边界总是属于第二个有序部分
   - 当 `nums[mid] > nums[right]` 时，说明中间元素属于第一个有序部分，最小值一定在右半部分

### 更直观的例子

考虑数组 `nums = [3,4,5,1,2]`：

**与右边界比较：**
- `nums[mid] = 5, nums[right] = 2`
- `5 > 2`，说明最小值在右半部分 ✅

**与左边界比较：**
- `nums[mid] = 5, nums[left] = 3`
- `5 > 3`，但这不能确定最小值在哪里 ❌


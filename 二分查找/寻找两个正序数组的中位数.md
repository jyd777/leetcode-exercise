# 寻找两个正序数组的中位数

给定两个大小分别为 `m` 和 `n` 的正序（从小到大）数组 `nums1` 和 `nums2`。请你找出并返回这两个正序数组的 **中位数** 。

算法的时间复杂度应该为 `O(log (m+n))` 。

 

**示例 1：**

```
输入：nums1 = [1,3], nums2 = [2]
输出：2.00000
解释：合并数组 = [1,2,3] ，中位数 2
```

**示例 2：**

```
输入：nums1 = [1,2], nums2 = [3,4]
输出：2.50000
解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5
```

 

 

**提示：**

- `nums1.length == m`
- `nums2.length == n`
- `0 <= m <= 1000`
- `0 <= n <= 1000`
- `1 <= m + n <= 2000`
- `-106 <= nums1[i], nums2[i] <= 106`

## 解决方案

```cpp
class Solution {
public:
    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
        // 确保nums1是较短数组，保证迭代次数少
        if(nums1.size() > nums2.size())
            return findMedianSortedArrays(nums2, nums1);
        // 开始处理
        int m = nums1.size(), n = nums2.size();
        // 将该问题中需要查找的内容改为nums1在中位数左边该有多少个元素
        int left = 0, right = m; // 搜索nums1中左半部分元素该有多少个的范围
        int left_size = (m+n+1)/2; // 左半部分的元素个数
        // 二分查找，左右都是闭区间
        while(left <= right){
            // nums1中左半部分元素个数
            int i = (left+right)/2;
            // nums2中的左半部分元素个数
            int j = left_size-i;
            
            // 计算二分查找的判断依据
            // nums1左半部分的最大值
            int nums1_left_max = (i==0) ? INT_MIN : nums1[i-1];
            // nums1右半部分的最小值
            int nums1_right_min = (i==m) ? INT_MAX : nums1[i];
            // nums2左半部分的最大值
            int nums2_left_max = (j==0) ? INT_MIN : nums2[j-1];
            // nums2右半部分的最小值
            int nums2_right_min = (j==n) ? INT_MAX : nums2[j];
            
            // 检查分割的正确性
            if(nums1_left_max <= nums2_right_min && nums2_left_max <= nums1_right_min){
                // 分割正确
                if((m+n)%2)
                    // 奇数个元素，中位数是左半部分的最大值
                    return max(nums1_left_max, nums2_left_max);
                else
                    // 偶数个元素，中位数是左半部分最大值和右半部分最小值的平均值
                    return (max(nums1_left_max, nums2_left_max)+min(nums1_right_min, nums2_right_min))/2.0;
            }
            else if (nums1_left_max > nums2_right_min)
                // nums1左半部分太多
                right = i-1;
            else
                // nums1左半部分太少
                left = i+1;
        }
        return 0.0;
    }
};
```

## 算法思路

1. **问题转化**：
   - 寻找中位数等价于找到正确的分割点
   - 将两个数组分成左右两部分，使得左半部分的所有元素都小于右半部分

2. **分割条件**：
   - 左半部分包含 `(m + n + 1) / 2` 个元素
   - 左半部分的最大值 ≤ 右半部分的最小值

3. **二分查找**：
   - 在较短的数组上进行二分查找
   - 确定该数组中左半部分的元素个数
   - 根据分割条件调整搜索范围

## 关键变量说明

- `i`：nums1 中左半部分的元素个数
- `j`：nums2 中左半部分的元素个数
- `totalLeft`：左半部分应该有的总元素个数
- `nums1LeftMax`：nums1 左半部分的最大值
- `nums1RightMin`：nums1 右半部分的最小值
- `nums2LeftMax`：nums2 左半部分的最大值
- `nums2RightMin`：nums2 右半部分的最小值

## 分割条件检查

```cpp
if (nums1LeftMax <= nums2RightMin && nums2LeftMax <= nums1RightMin) {
    // 分割正确
}
```

这个条件确保：
1. nums1 左半部分的最大值 ≤ nums2 右半部分的最小值
2. nums2 左半部分的最大值 ≤ nums1 右半部分的最小值

## 示例分析

对于 `nums1 = [1,3], nums2 = [2]`：

1. 确保 nums1 是较短的数组
2. `totalLeft = (2 + 1 + 1) / 2 = 2`
3. 二分查找确定 nums1 中左半部分的元素个数
4. 找到正确的分割点后计算中位数

## 时间复杂度

- 时间复杂度：O(log(min(m, n)))
- 空间复杂度：O(1)

## **🤔为何要确保 `nums1` 是较短的数组有几个重要原因：**

### 1. 时间复杂度优化

#### 二分查找的复杂度
- 如果我们在较短的数组上进行二分查找，时间复杂度是 `O(log(min(m, n)))`
- 如果我们在较长的数组上进行二分查找，时间复杂度是 `O(log(max(m, n)))`

#### 具体例子
假设 `nums1` 长度为 1000，`nums2` 长度为 100：
- 在 `nums1` 上二分查找：`log(1000) ≈ 10` 次迭代
- 在 `nums2` 上二分查找：`log(100) ≈ 7` 次迭代

选择较短的数组可以显著减少迭代次数！

### 2. 边界情况处理简化

#### 当 `j` 可能为负数时
```cpp
int j = totalLeft - i;
```

如果 `nums1` 较长，`i` 可能很大，导致 `j` 为负数，这会导致数组越界。

#### 例子说明
假设 `nums1 = [1,2,3,4,5]`，`nums2 = [6]`：
- `totalLeft = (5 + 1 + 1) / 2 = 3`
- 如果 `i = 4`，那么 `j = 3 - 4 = -1`
- 访问 `nums2[-1]` 会导致越界

但如果 `nums1` 是较短的数组，`i` 不会超过 `nums1` 的长度，`j` 不会为负数。

### 3. 算法逻辑的一致性

#### 分割点的含义
- `i` 表示 `nums1` 中左半部分的元素个数
- `j` 表示 `nums2` 中左半部分的元素个数

当 `nums1` 较短时，`i` 的范围是 `[0, m]`，这更符合直觉。

### 4. 具体例子验证

#### 例子1：nums1较短
```
nums1 = [1, 3], nums2 = [2, 4, 5, 6]
totalLeft = (2 + 4 + 1) / 2 = 3
i 的范围：[0, 2]
j 的范围：[1, 3] (因为 j = totalLeft - i)
```

#### 例子2：nums1较长（不推荐）
```
nums1 = [1, 2, 3, 4, 5], nums2 = [6]
totalLeft = (5 + 1 + 1) / 2 = 3
i 的范围：[0, 5]
j 的范围：[-2, 3] (可能为负数！)
```

## 边界情况处理

1. **空数组**：通过 INT_MIN 和 INT_MAX 处理
2. **单元素数组**：算法仍然有效
3. **所有元素相等**：算法仍然有效

## 你的代码问题分析

```cpp
// 你的代码问题
class Solution {
public:
    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
        // 确保nums1是较短数组，保证迭代次数少
        if(nums1.size() > nums2.size())
            return findMedianSortedArrays(nums2, nums1);
        // 开始处理
        int m = nums1.size(), n = nums2.size();
        int left = 0, right = m;
        int left_size = (m+n+1)/2; // 左半部分的元素个数
        // 二分查找，左右都是闭区间
        while(left <= right){
            // nums1中左半部分元素个数
            int i = (left+right)/2;
            // nums2中的左半部分元素个数
            int j = left_size-i;
            
            // 计算二分查找的判断依据
            // nums1左半部分的最大值
            int nums1_left_max = (i==0) ? INT_MIN : nums1[i-1];
            // nums1右半部分的最小值
            int nums1_right_min = (i==m) ? INT_MAX : nums1[i];
            // nums2左半部分的最大值
            int nums2_left_max = (j==0) ? INT_MIN : nums2[j-1];
            // nums2右半部分的最小值
            int nums2_right_min = (j==n) ? INT_MAX : nums2[j];
            
            // 检查分割的正确性
            if(nums1_left_max <= nums2_right_min && nums2_left_max <= nums1_right_min){
                // 分割正确
                if((m+n)%2)
                    // 奇数个元素，中位数是左半部分的最大值
                    return max(nums1_left_max, nums2_left_max);
                else
                    // 偶数个元素，中位数是左半部分最大值和右半部分最小值的平均值
                    return (max(nums1_left_max, nums2_left_max)+min(nums1_right_min, nums2_right_min))/2;  // 问题1：整数除法
            }
            else if (nums1_left_max > nums2_right_min)
                // nums1左半部分太多
                right = i-1;
            else
                // nums1左半部分太少
                left = i+1;
        }
        return 0.0;
    }
};
```

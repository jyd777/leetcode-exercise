# 下一个排列

整数数组的一个 **排列** 就是将其所有成员以序列或线性顺序排列。

- 例如，`arr = [1,2,3]` ，以下这些都可以视作 `arr` 的排列：`[1,2,3]`、`[1,3,2]`、`[3,1,2]`、`[2,3,1]` 。

整数数组的 **下一个排列** 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 **下一个排列** 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。

- 例如，`arr = [1,2,3]` 的下一个排列是 `[1,3,2]` 。
- 类似地，`arr = [2,3,1]` 的下一个排列是 `[3,1,2]` 。
- 而 `arr = [3,2,1]` 的下一个排列是 `[1,2,3]` ，因为 `[3,2,1]` 不存在一个字典序更大的排列。

给你一个整数数组 `nums` ，找出 `nums` 的下一个排列。

必须**[ 原地 ](https://baike.baidu.com/item/原地算法)**修改，只允许使用额外常数空间。

 

**示例 1：**

```
输入：nums = [1,2,3]
输出：[1,3,2]
```

**示例 2：**

```
输入：nums = [3,2,1]
输出：[1,2,3]
```

**示例 3：**

```
输入：nums = [1,1,5]
输出：[1,5,1]
```

 

**提示：**

- `1 <= nums.length <= 100`
- `0 <= nums[i] <= 100`



**算法关键点：**

1. **递减序列**：从右向左的递减序列已经是字典序最大的部分
2. **交换**：找到第一个可以"升级"的位置
3. **反转**：将递减序列反转，得到字典序最小的排列

```cpp
class Solution {
public:
    void nextPermutation(vector<int>& nums) {
        int n = nums.size();
        if (n <= 1) return;
        // 除了这个组合中字典序最大的以外，其它的都是下一个会比当前的字典序大，也就是会把原本排在后面的一个更大的数值和前一个较小的交换
        // 如何保证是下一个呢？
        // （1）找到最靠近右边的需要交换的数
        //  要交换的数要满足比后一个数要小，也就是说有可以交换的数值，有变大的空间
        // 由此，得到了：STEP1 从右向左找到第一个递减的位置
        int i = n-2;
        while(i>=0 && nums[i] >= nums[i+1])
            i--;
        // （2）找到和这个数交换的数
        //  这个数应该要比当前数略大，而且要位于这个数的右边，也就是比这个数大的最小的那个数
        // 而又因为这个数右边的数字是递减的，所以从右向左找到的第一个大于nums[i]的数就是右边所有大于nums[i]的数中的最小值
        // STEP2 从右向左找到第一个大于nums[i]的数
        if(i>=0){
            // 如果找到了递减位置
            int j = n-1;
            while(j>i && nums[j] <= nums[i])
                j--;
            swap(nums[i], nums[j]);
        }
        // 但是在交换后这个数原来的位置的右侧的数都是递减的，也就是是这些数可以排列出来字典序最大的情况，这时候需要反转，由此来保证求的是下一个排列
        // STEP3 反转i+1到末尾的部分
        reverse(nums.begin()+i+1, nums.end());
    }
};
```

**示例1：`nums = [1,3,4,2]`**

**目标：** 找到下一个排列

**步骤1：从右向左找递减位置**

```
数组：[1, 3, 4, 2]
索引： 0  1  2  3

从右向左扫描：
- nums[3]=2, nums[2]=4: 2 < 4 ✓ (递减)
- nums[2]=4, nums[1]=3: 4 > 3 ✗ (递增，找到了！)

所以 i = 1 (nums[1]=3)
```

**步骤2：找替换数**

```
在位置i=1右边找第一个大于nums[1]=3的数：
- nums[2]=4 > 3 ✓
- nums[3]=2 < 3 ✗

所以 j = 2 (nums[2]=4)
```

**步骤3：交换**

```
交换 nums[1]=3 和 nums[2]=4：
[1, 3, 4, 2] → [1, 4, 3, 2]
```

**步骤4：反转递减序列**

```
反转位置i+1=2到末尾的部分：
[1, 4, 3, 2] → [1, 4, 2, 3]
```

**最终结果：** `[1, 4, 2, 3]`



**示例2：`nums = [4, 3, 2, 1]`**

**步骤1：找递减位置**

```
从右向左扫描：
- nums[3]=1, nums[2]=2: 1 < 2 ✓
- nums[2]=2, nums[1]=3: 2 < 3 ✓  
- nums[1]=3, nums[0]=4: 3 < 4 ✓

整个数组都是递减的，所以 i = -1
```

**步骤2：跳过（因为i < 0）**

**步骤3：反转整个数组**

```
[4, 3, 2, 1] → [1, 2, 3, 4]
```

**结果：** `[1, 2, 3, 4]` (字典序最小的排列)

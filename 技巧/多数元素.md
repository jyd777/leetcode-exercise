# 多数元素

给定一个大小为 `n` 的数组 `nums` ，返回其中的多数元素。多数元素是指在数组中出现次数 **大于** `⌊ n/2 ⌋` 的元素。

你可以假设数组是非空的，并且给定的数组总是存在多数元素。

 

**示例 1：**

```
输入：nums = [3,2,3]
输出：3
```

**示例 2：**

```
输入：nums = [2,2,1,1,1,2,2]
输出：2
```

 

**提示：**

- `n == nums.length`
- `1 <= n <= 5 * 104`
- `-109 <= nums[i] <= 109`

 

**进阶：**尝试设计时间复杂度为 O(n)、空间复杂度为 O(1) 的算法解决此问题。



**Boyer-Moore 投票算法**是最优的解法，满足进阶要求：

- **时间复杂度**：O(n)
- **空间复杂度**：O(1)

**算法原理：**

1. **候选者**：将第一个元素作为候选者
2. **计数**：遇到相同元素计数+1，遇到不同元素计数-1
3. **更换候选者**：当计数为0时，更换当前元素为候选者
4. **最终结果**：遍历结束后，候选者就是多数元素

**为什么这个算法有效：**

- 由于多数元素出现次数超过一半，即使其他所有元素都与它"对抗"，它的计数最终也会大于0
- 算法本质上是"抵消"过程，多数元素最终会胜出

**示例：**

对于数组 `[2,2,1,1,1,2,2]`：

- 候选者：2，计数：1
- 候选者：2，计数：2  
- 候选者：2，计数：1
- 候选者：2，计数：0
- 候选者：1，计数：1
- 候选者：1，计数：0
- 候选者：2，计数：1

最终候选者：2（多数元素）

```cpp
class Solution {
public:
    int majorityElement(vector<int>& nums) {
        int ret = nums[0];
        int cnt = 1;
        for(int i=1;i<nums.size();i++){
            if(cnt == 0){
                // 更换候选者
                ret = nums[i];
                cnt = 1;
            }
            else if(nums[i] == ret)
                cnt++;
            else
                cnt--;
        }
        return ret;
    }
};
```


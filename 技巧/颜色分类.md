# 颜色分类

给定一个包含红色、白色和蓝色、共 `n` 个元素的数组 `nums` ，**[原地](https://baike.baidu.com/item/原地算法)** 对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。

我们使用整数 `0`、 `1` 和 `2` 分别表示红色、白色和蓝色。

必须在不使用库内置的 sort 函数的情况下解决这个问题。

 

**示例 1：**

```
输入：nums = [2,0,2,1,1,0]
输出：[0,0,1,1,2,2]
```

**示例 2：**

```
输入：nums = [2,0,1]
输出：[0,1,2]
```

 

**提示：**

- `n == nums.length`
- `1 <= n <= 300`
- `nums[i]` 为 `0`、`1` 或 `2`

 

**进阶：**

- 你能想出一个仅使用常数空间的一趟扫描算法吗？



**方法一：三指针（荷兰国旗算法）**

- **时间复杂度**：O(n)
- **空间复杂度**：O(1)
- **遍历次数**：1次
- **优点**：一次遍历，原地操作
- **缺点**：逻辑稍复杂

```cpp
class Solution {
public:
    void sortColors(vector<int>& nums) {
        int left = 0;        // 指向0的右边界
        int right = nums.size() - 1;  // 指向2的左边界
        int cur = 0;        // 当前遍历指针
        while(cur <= right){
            if(nums[cur] == 0){
                // 交换到左边
                swap(nums[cur], nums[left]);
                cur++;
                left++;
            }
            else if(nums[cur] == 1)
                cur++;
            else{
                swap(nums[cur], nums[right]);
                right--;
                //cur不移动，因为交换过来的可能是0或1
            }
        }
    }
};
```

- **left左边**：保证都是0
- **right右边**：保证都是2
- **中间区域**：curr遍历，遇到1就跳过，遇到0或2就交换到正确位置

**荷兰国旗算法演示**

**输入：** `nums = [2,0,2,1,1,0]`

**初始状态：**

```
数组：[2, 0, 2, 1, 1, 0]
索引： 0  1  2  3  4  5
指针： left=0, curr=0, right=5
```

**步骤1：curr=0, nums[0]=2**

```
当前：nums[0]=2 (红色)
操作：与right交换，right--
数组：[0, 0, 2, 1, 1, 2]
指针： left=0, curr=0, right=4
```

**步骤2：curr=0, nums[0]=0**

```
当前：nums[0]=0 (白色)
操作：与left交换，left++, curr++
数组：[0, 0, 2, 1, 1, 2]
指针： left=1, curr=1, right=4
```

**步骤3：curr=1, nums[1]=0**

```
当前：nums[1]=0 (白色)
操作：与left交换，left++, curr++
数组：[0, 0, 2, 1, 1, 2]
指针： left=2, curr=2, right=4
```

**步骤4：curr=2, nums[2]=2**

```
当前：nums[2]=2 (红色)
操作：与right交换，right--
数组：[0, 0, 1, 1, 2, 2]
指针： left=2, curr=2, right=3
```

**步骤5：curr=2, nums[2]=1**

```
当前：nums[2]=1 (蓝色)
操作：curr++ (跳过)
数组：[0, 0, 1, 1, 2, 2]
指针： left=2, curr=3, right=3
```

**步骤6：curr=3, nums[3]=1**

```
当前：nums[3]=1 (蓝色)
操作：curr++ (跳过)
数组：[0, 0, 1, 1, 2, 2]
指针： left=2, curr=4, right=3
```

**结束条件**

```
curr=4 > right=3，循环结束
最终结果：[0, 0, 1, 1, 2, 2]
```

**方法二：计数排序**

- **时间复杂度**：O(n)
- **空间复杂度**：O(1)（只用了几个变量）
- **遍历次数**：2次
- **优点**：简单直观
- **缺点**：需要两次遍历

```cpp
class Solution {
public:
    void sortColors(vector<int>& nums) {
        int cnt[3]= {0,0,0};
        for(int num :nums)
            cnt[num]++;
        int index = 0;
        for(int i=0;i<cnt[0];i++)
            nums[index++] = 0;
        for(int i=0;i<cnt[1];i++)
            nums[index++] = 1;
        for(int i=0;i<cnt[2];i++)
            nums[index++] = 2;
    }
};
```


# 寻找重复数

给定一个包含 `n + 1` 个整数的数组 `nums` ，其数字都在 `[1, n]` 范围内（包括 `1` 和 `n`），可知至少存在一个重复的整数。

假设 `nums` 只有 **一个重复的整数** ，返回 **这个重复的数** 。

你设计的解决方案必须 **不修改** 数组 `nums` 且只用常量级 `O(1)` 的额外空间。

 

**示例 1：**

```
输入：nums = [1,3,4,2,2]
输出：2
```

**示例 2：**

```
输入：nums = [3,1,3,4,2]
输出：3
```

**示例 3 :**

```
输入：nums = [3,3,3,3,3]
输出：3
```

 

 

**提示：**

- `1 <= n <= 105`
- `nums.length == n + 1`
- `1 <= nums[i] <= n`
- `nums` 中 **只有一个整数** 出现 **两次或多次** ，其余整数均只出现 **一次**

 

**进阶：**

- 如何证明 `nums` 中至少存在一个重复的数字?
- 你可以设计一个线性级时间复杂度 `O(n)` 的解决方案吗？



```cpp
class Solution {
public:
    int findDuplicate(vector<int>& nums) {
        // 以数组中元素的值为索引，来更新遍历
        //因为会有一个数重复，也就相当于会有两个索引值一模一样，即存在有一个圈，而重复的元素也就是那个圈的入口点
        // 在链表问题中，找到圈的入口点可以用快慢指针
        int slow = nums[0];
        int fast = nums[0];
        // STEP1:找到相遇点
        do{
            slow = nums[slow];
            fast = nums[nums[fast]];
        }while(slow!=fast);
        // STEP2：找到入口点
        // 慢指针回到起点，快指针从相遇点出发，速度都为1，再次相遇时即为环入口
        slow = nums[0];
        while(slow!=fast){
            slow = nums[slow];
            fast = nums[fast];
        }
        return slow;
    }
};
```

**将数组看作链表：**

- 数组索引作为节点
- 数组值作为下一个节点的索引
- 重复数会形成环

**举例：`nums = [1,3,4,2,2]`**

```
索引：0 -> 1 -> 3 -> 2 -> 4 -> 2 -> 4 -> 2 -> ...
值：  1 -> 3 -> 2 -> 4 -> 2 -> 4 -> 2 -> 4 -> ...
```

**快慢指针过程：**

1. **第一阶段**：找到相遇点
   - slow: 1 -> 3 -> 2 -> 4 -> 2
   - fast: 1 -> 2 -> 4 -> 2 -> 4
   - 在值2处相遇

2. **第二阶段**：找到环入口
   - slow从起点重新开始
   - fast从相遇点开始
   - 两者相遇的地方就是重复数
# 最长递增子序列

给你一个整数数组 `nums` ，找到其中最长严格递增子序列的长度。

**子序列** 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，`[3,6,2,7]` 是数组 `[0,3,1,6,2,2,7]` 的子序列。

**示例 1：**

```
输入：nums = [10,9,2,5,3,7,101,18]
输出：4
解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。
```

**示例 2：**

```
输入：nums = [0,1,0,3,2,3]
输出：4
```

**示例 3：**

```
输入：nums = [7,7,7,7,7,7,7]
输出：1
```

 

**提示：**

- `1 <= nums.length <= 2500`
- `-104 <= nums[i] <= 104`

 

**进阶：**

- 你能将算法的时间复杂度降低到 `O(n log(n))` 吗?



## 动态规划解法

**状态定义：** `dp[i]` 表示以第i个元素结尾的最长递增子序列的长度

**状态转移方程：** `dp[i] = max(dp[j] + 1)` 其中0 ≤ j < i 且 nums[j] < nums[i]

**边界条件：** `dp[i] = 1` 对所有i

```cpp
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        int n = nums.size();
        if (n == 0) return 0;
        
        // dp[i] 表示以第i个元素结尾的最长递增子序列的长度
        vector<int> dp(n, 1);  // 每个元素至少可以构成长度为1的子序列
        
        for(int i=1;i<n;i++){
            // 检查前面所有元素
            for(int j=0;j<i;j++){
                if(nums[i]>nums[j])
                    dp[i] = max(dp[i], dp[j]+1);
            }
        }
        sort(dp.begin(),dp.end());
        return dp[n-1];
    }
};
```

**时间复杂度：** O(n²)

**空间复杂度：** O(n)

**动态规划思路解释：**
1. **状态定义**：`dp[i]` 表示以第i个元素结尾的最长递增子序列的长度
2. **状态转移**：对于每个元素nums[i]，检查所有前面的元素nums[j]，如果nums[j] < nums[i]，则可以将nums[i]接在nums[j]后面
3. **边界条件**：每个元素至少可以构成长度为1的子序列
4. **最终结果**：返回所有dp值中的最大值

**为什么这样是正确的：**
- 对于每个位置i，我们需要检查所有前面的位置j
- 如果nums[j] < nums[i]，那么nums[i]可以接在nums[j]后面形成更长的递增子序列
- 这保证了最优子结构性质

**示例分析：**
- nums = [10,9,2,5,3,7,101,18]
- dp[0] = 1
- dp[1] = 1 (9不能接在10后面)
- dp[2] = 1 (2不能接在10或9后面)
- dp[3] = 2 (5可以接在2后面)
- dp[4] = 2 (3可以接在2后面)
- dp[5] = 3 (7可以接在2,3后面)
- dp[6] = 4 (101可以接在2,3,7后面)
- dp[7] = 4 (18可以接在2,3,7后面)



## 进阶：O(n log n)解法详解

使用二分查找优化：

```cpp
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        vector<int> tails;  // tails[i]表示长度为i+1的递增子序列的最小末尾值
        
        for (int num : nums) {
            // 二分查找num应该插入的位置
            auto it = lower_bound(tails.begin(), tails.end(), num);
            if (it == tails.end()) {
                tails.push_back(num);  // num比所有末尾值都大
            } else {
                *it = num;  // 更新对应长度的最小末尾值
            }
        }
        
        return tails.size();
    }
};
```

**时间复杂度：** O(n log n)

**空间复杂度：** O(n)

### 核心思想：
维护一个数组 `tails`，其中 `tails[i]` 表示长度为 `i+1` 的递增子序列的最小末尾值。

### 算法步骤：

1. **初始化**：`tails` 为空数组

2. **遍历每个数字**：
   - 对于每个数字 `num`，使用二分查找在 `tails` 中找到第一个大于等于 `num` 的位置
   - 如果找到位置 `it`：
     - 如果 `it == tails.end()`：说明 `num` 比所有末尾值都大，可以扩展最长子序列
     - 否则：用 `num` 替换 `*it`，因为 `num` 更小，更有利于后续扩展

3. **最终结果**：`tails.size()` 就是最长递增子序列的长度

### 示例演示：

对于 `nums = [10,9,2,5,3,7,101,18]`：

```
初始：tails = []

num = 10: tails = [10]
num = 9:  tails = [9]     (9替换10，因为9更小)
num = 2:  tails = [2]     (2替换9，因为2更小)
num = 5:  tails = [2,5]   (5比2大，可以扩展)
num = 3:  tails = [2,3]   (3替换5，因为3更小)
num = 7:  tails = [2,3,7] (7比3大，可以扩展)
num = 101: tails = [2,3,7,101] (101比7大，可以扩展)
num = 18: tails = [2,3,7,18]   (18替换101，因为18更小)
```

### 为什么这样是正确的：

1. **贪心策略**：对于相同长度的递增子序列，我们总是选择末尾值最小的那个，这样更有利于后续扩展

2. **单调性**：`tails` 数组是严格递增的，这保证了二分查找的正确性

3. **最优性**：每次更新都保持了最优子结构，最终 `tails.size()` 就是最长递增子序列的长度

### 时间复杂度分析：

- **外层循环**：O(n)
- **内层二分查找**：O(log n)
- **总时间复杂度**：O(n log n)

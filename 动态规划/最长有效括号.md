# 最长有效括号

给你一个只包含 `'('` 和 `')'` 的字符串，找出最长有效（格式正确且连续）括号子串的长度。

 

**示例 1：**

```
输入：s = "(()"
输出：2
解释：最长有效括号子串是 "()"
```

**示例 2：**

```
输入：s = ")()())"
输出：4
解释：最长有效括号子串是 "()()"
```

**示例 3：**

```
输入：s = ""
输出：0
```

 

**提示：**

- `0 <= s.length <= 3 * 104`
- `s[i]` 为 `'('` 或 `')'`



```cpp
class Solution {
public:
    int longestValidParentheses(string s) {
        int n = s.length();
        if(!n)
            return 0;
        // dp[i] 表示以 s[i] 结尾的最长有效括号长度
        vector<int> dp(n, 0);
        int ret = 0;
        for(int i=1;i<n;i++){
            if(s[i]==')'){
                if(s[i-1]=='(')
                    // 匹配上了
                    dp[i] = (i>=2?dp[i-2]:0)+2;
                else if(s[i-1]==')'){
                    // 要找到和s[i-1]匹配的(的前一个符号
                    int left_pos = i-1-dp[i-1];
                    if(left_pos>=0 && s[left_pos]=='(')
                        // 此时还要加上left_pos左边的长度（可能原本两个孤立的有效子串可以合并了）
                        dp[i] = dp[i-1]+2+(left_pos>0?dp[left_pos-1]:0);
                }
            }
            ret = max(ret,dp[i]);
        }
        return ret;
    }
};
```



**状态转移方程解释：**

**状态定义：**

- `dp[i]`：以 `s[i]` 结尾的最长有效括号长度

**转移方程：**

1. **当 `s[i] == '('` 时**：
   - `dp[i] = 0`（因为有效括号必须以右括号结尾）

2. **当 `s[i] == ')'` 时**：
   - **情况1**：`s[i-1] == '('`
     - `dp[i] = dp[i-2] + 2`
     - 直接匹配，长度加2

   - **情况2**：`s[i-1] == ')'`
     - 需要找到与当前右括号匹配的左括号
     - 左括号位置：`leftPos = i - dp[i-1] - 1`
     - 如果 `s[leftPos] == '('`，则：
       - `dp[i] = dp[i-1] + 2 + dp[leftPos-1]`

**示例分析：**

以 `s = ")()())"` 为例：

- `dp[0] = 0`（右括号开头）
- `dp[1] = 2`（匹配到左括号）
- `dp[2] = 0`（左括号）
- `dp[3] = 4`（匹配到左括号，加上前面的有效长度）
- `dp[4] = 0`（右括号）
- `dp[5] = 0`（右括号）

最终结果为 `max(dp) = 4`。

**复杂度：**

- 时间复杂度： O(n)
- 空间复杂度： O(n)
# 字符串解码

给定一个经过编码的字符串，返回它解码后的字符串。

编码规则为: `k[encoded_string]`，表示其中方括号内部的 `encoded_string` 正好重复 `k` 次。注意 `k` 保证为正整数。

你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。

此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 `k` ，例如不会出现像 `3a` 或 `2[4]` 的输入。

 

**示例 1：**

```
输入：s = "3[a]2[bc]"
输出："aaabcbc"
```

**示例 2：**

```
输入：s = "3[a2[c]]"
输出："accaccacc"
```

**示例 3：**

```
输入：s = "2[abc]3[cd]ef"
输出："abcabccdcdcdef"
```

**示例 4：**

```
输入：s = "abc3[cd]xyz"
输出："abccdcdcdxyz"
```

 

**提示：**

- `1 <= s.length <= 30`
- `s` 由小写英文字母、数字和方括号 `'[]'` 组成
- `s` 保证是一个 **有效** 的输入。
- `s` 中所有整数的取值范围为 `[1, 300]` 

## 解决方案

```cpp
class Solution {
public:
    string decodeString(string s) {
        stack<string> str_stack;
        stack<int> num_stack; 
        string ret = "";
        int cur_num = 0;
        string cur_str = "";
        for(char c:s){
            if(c>='0'&& c<='9')
                // 可能是多位数
                cur_num = cur_num*10+(c-'0');
            else if(c == '['){
                str_stack.push(cur_str);
                num_stack.push(cur_num);
                // 还原
                cur_str = "";
                cur_num = 0;
            }
            else if(c == ']'){
                // 重复次数
                int re_time = num_stack.top();
                num_stack.pop();
                // 重复当前字符串
                string tmp = "";
                while(re_time--)
                    tmp+=cur_str;
                // 拼接的字符串
                string prev_str = str_stack.top();
                str_stack.pop(); 
                cur_str = prev_str + tmp;
            }
            else
                // 字符
                cur_str += c;
        }
        return cur_str;
    }
};
```

## 算法思路

### 核心思想：双栈法
使用两个栈来处理嵌套的编码字符串：
1. **字符串栈 (strStack)**：存储待拼接的字符串
2. **数字栈 (numStack)**：存储重复次数

### 处理逻辑：

1. **数字处理**：
   - 使用 `currentNum` 累积多位数
   - 遇到非数字时重置 `currentNum`

2. **左括号 `[`**：
   - 保存当前字符串和数字到栈中
   - 重置当前状态

3. **右括号 `]`**：
   - 取出栈顶的数字（重复次数）
   - 取出栈顶的字符串（前缀）
   - 重复当前字符串并与前缀拼接

4. **普通字符**：
   - 直接添加到当前字符串

### 示例分析

以 `"3[a2[c]]"` 为例：

```
遍历过程：
'3': currentNum = 3
'[': strStack=[], numStack=[3], currentStr="", currentNum=0
'a': currentStr = "a"
'2': currentNum = 2
'[': strStack=["a"], numStack=[3,2], currentStr="", currentNum=0
'c': currentStr = "c"
']': repeatTimes=2, prevStr="a", currentStr="cc"
']': repeatTimes=3, prevStr="", currentStr="accaccacc"
```

## 时间复杂度
- **时间复杂度**：O(n)，其中 n 是输出字符串的长度
- **空间复杂度**：O(n)，栈的空间开销

## 优化版本

也可以使用递归方法：

```cpp
class Solution {
private:
    int index = 0;
    
public:
    string decodeString(string s) {
        return decodeHelper(s);
    }
    
    string decodeHelper(string& s) {
        string result = "";
        int num = 0;
        
        while (index < s.length()) {
            char c = s[index];
            
            if (isdigit(c)) {
                num = num * 10 + (c - '0');
            } else if (c == '[') {
                index++; // 跳过 '['
                string inner = decodeHelper(s);
                for (int i = 0; i < num; i++) {
                    result += inner;
                }
                num = 0;
            } else if (c == ']') {
                return result;
            } else {
                result += c;
            }
            index++;
        }
        
        return result;
    }
};
```
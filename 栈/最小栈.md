# 最小栈

设计一个支持 `push` ，`pop` ，`top` 操作，并能在常数时间内检索到最小元素的栈。

实现 `MinStack` 类:

- `MinStack()` 初始化堆栈对象。
- `void push(int val)` 将元素val推入堆栈。
- `void pop()` 删除堆栈顶部的元素。
- `int top()` 获取堆栈顶部的元素。
- `int getMin()` 获取堆栈中的最小元素。

 

**示例 1:**

```
输入：
["MinStack","push","push","push","getMin","pop","top","getMin"]
[[],[-2],[0],[-3],[],[],[],[]]

输出：
[null,null,null,null,-3,null,0,-2]

解释：
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin();   --> 返回 -3.
minStack.pop();
minStack.top();      --> 返回 0.
minStack.getMin();   --> 返回 -2.
```

 

**提示：**

- `-231 <= val <= 231 - 1`
- `pop`、`top` 和 `getMin` 操作总是在 **非空栈** 上调用
- `push`, `pop`, `top`, and `getMin`最多被调用 `3 * 104` 次

## 解决方案

```cpp
class MinStack {
private:
    stack<int> data_st; // 存储数值
    stack<int> min_st; // 存储当前位置对应的最小值
public:
    MinStack() {
        
    }
    
    void push(int val) {
        data_st.push(val);
        if(min_st.empty() || val <= min_st.top())
            min_st.push(val);
        else
            min_st.push(min_st.top());
    }
    
    void pop() {
        data_st.pop();
        min_st.pop();
    }
    
    int top() {
        return data_st.top();
    }
    
    int getMin() {
        return min_st.top();
    }
};

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack* obj = new MinStack();
 * obj->push(val);
 * obj->pop();
 * int param_3 = obj->top();
 * int param_4 = obj->getMin();
 */
```

## 算法思路

### 核心思想：双栈法
使用两个栈来维护数据：
1. **主栈 (dataStack)**：存储所有推入的元素
2. **最小栈 (minStack)**：存储每个位置对应的最小值

### 操作逻辑：

1. **push(val)**：
   - 将val推入主栈
   - 如果最小栈为空或val <= 当前最小值，将val推入最小栈
   - 否则，将当前最小值重复推入最小栈

2. **pop()**：
   - 同时弹出两个栈的栈顶元素

3. **top()**：
   - 返回主栈的栈顶元素

4. **getMin()**：
   - 返回最小栈的栈顶元素

### 示例分析

以示例 `[-2, 0, -3]` 为例：

```
操作序列：
push(-2): dataStack=[-2], minStack=[-2]
push(0):  dataStack=[-2,0], minStack=[-2,-2]  (0>-2，重复压入-2)
push(-3): dataStack=[-2,0,-3], minStack=[-2,-2,-3]  (-3<-2，压入-3)
getMin(): 返回-3
pop():    dataStack=[-2,0], minStack=[-2,-2]
top():    返回0
getMin(): 返回-2
```

## 时间复杂度
- **所有操作**：O(1) 时间复杂度
- **空间复杂度**：O(n)，需要额外的栈来存储最小值

## 优化方案

也可以使用一个栈存储pair来优化空间：

```cpp
class MinStack {
private:
    stack<pair<int, int>> st; // pair<当前值, 当前最小值>
    
public:
    void push(int val) {
        int minVal = st.empty() ? val : min(val, st.top().second);
        st.push({val, minVal});
    }
    
    void pop() {
        st.pop();
    }
    
    int top() {
        return st.top().first;
    }
    
    int getMin() {
        return st.top().second;
    }
};
```
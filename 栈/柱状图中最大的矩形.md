# 柱状图中最大的矩形

给定 *n* 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。

求在该柱状图中，能够勾勒出来的矩形的最大面积。

 

**示例 1:**

![img](https://assets.leetcode.com/uploads/2021/01/04/histogram.jpg)

```
输入：heights = [2,1,5,6,2,3]
输出：10
解释：最大的矩形为图中红色区域，面积为 10
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2021/01/04/histogram-1.jpg)

```
输入： heights = [2,4]
输出： 4
```

 

**提示：**

- `1 <= heights.length <=105`
- `0 <= heights[i] <= 104`

## 解决方案

```cpp
class Solution {
public:
    int largestRectangleArea(vector<int>& heights) {
        int n = heights.size();
        vector<int> left(n),right(n);// 每个柱子的左边界和右边界
        stack<int> st; // 栈中高度从顶向下递减
        // 计算左边界（左边第一个比当前矩形小的柱子）
        for(int i=0;i<n;i++){
            while(!st.empty() && heights[st.top()] >= heights[i])
                st.pop();
            left[i] = st.empty()?-1:st.top();
            st.push(i);
        }
        // 清空栈
        while(!st.empty())
            st.pop();
        // 计算右边界（右边第一个比当前矩形小的柱子）
        for(int i=n-1;i>=0;i--){
            while(!st.empty() && heights[st.top()]>= heights[i])
                st.pop();
            right[i] = st.empty()?n:st.top();
            st.push(i);
        }
        // 计算每个矩形作为最大高度时的最大矩形面积
        int ret = 0;
        for(int i=0;i<n;i++){
            int cur_width = right[i]-left[i]-1;
            int tmp = heights[i] * cur_width;
            ret = max(ret,tmp);
        }
        return ret;
    }
};
```

## 算法思路

### 核心思想：单调栈 + 左右边界
对于每个柱子，找到它左右两边第一个比它小的柱子，这样就能确定以该柱子为高度的最大矩形。

### 处理逻辑：

1. **找左边界**：
   - 从左到右遍历，维护单调递增栈
   - 对于每个柱子，找到左边第一个比它小的柱子位置

2. **找右边界**：
   - 从右到左遍历，维护单调递增栈
   - 对于每个柱子，找到右边第一个比它小的柱子位置

3. **计算面积**：
   - 宽度 = 右边界 - 左边界 - 1
   - 面积 = 高度 × 宽度

## 时间复杂度
- **时间复杂度**：O(n)，每个元素最多入栈出栈一次
- **空间复杂度**：O(n)，需要额外的数组和栈空间

## 优化版本

也可以使用一次遍历的方法：

```cpp
class Solution {
public:
    int largestRectangleArea(vector<int>& heights) {
        heights.push_back(0);// 添加哨兵，保证所有元素都被处理
        int n = heights.size();
        stack<int> st;// 单调递减栈
        int ret =0;
        for(int i=0;i<n;i++){
            while(!st.empty() && heights[st.top()]>heights[i]){
                // 计算栈顶矩形的面积
                // 由于当前遇到了更矮的矩形heights[i]，所以可以确定右边界
                // 又由于这个栈是单调递减的，所以左边界就是在当前栈顶弹出后的新栈顶
                int height = heights[st.top()];
                st.pop();
                int width = st.empty()?i:i-st.top()-1;
                ret = max(ret, height*width);
            }
            st.push(i);
        }
        return ret;
    }
};
```

### 优化版本的核心思想

这个优化版本使用**单次遍历**和**哨兵技巧**，在遍历过程中直接计算面积，避免了两次遍历和额外的数组空间。

### 关键技巧解析

#### 1. **哨兵技巧**
```cpp
heights.push_back(0);  // 添加哨兵
```
- 在数组末尾添加一个高度为0的柱子
- 这个哨兵确保所有柱子都能被处理到
- 当遍历到哨兵时，会强制弹出栈中所有剩余的元素

#### 2. **单调栈维护**
```cpp
while (!st.empty() && heights[st.top()] > heights[i]) {
    // 处理栈顶元素
}
```
- 维护单调递增栈（栈中高度从底到顶递增）
- 当遇到更小的柱子时，栈中所有大于该柱子的元素都可以确定右边界

#### 3. **面积计算**
```cpp
int height = heights[st.top()];
st.pop();
int width = st.empty() ? i : i - st.top() - 1;
maxArea = max(maxArea, height * width);
```
- `height`：当前处理的柱子高度
- `width`：以该柱子为高度的矩形宽度
- 如果栈为空：宽度 = i（从开头到当前位置）
- 如果栈不为空：宽度 = i - st.top() - 1（从栈顶位置到当前位置）

### 详细示例分析

以 `[2,1,5,6,2,3]` 为例，添加哨兵后变为 `[2,1,5,6,2,3,0]`：

```
遍历过程：
i=0, heights[0]=2: st=[], 直接入栈, st=[0]
i=1, heights[1]=1: 1<2, 弹出栈顶
  - height=2, st=[], width=1-(-1)-1=1, area=2×1=2
  - st=[1]
i=2, heights[2]=5: st=[1], 直接入栈, st=[1,2]
i=3, heights[3]=6: st=[1,2], 直接入栈, st=[1,2,3]
i=4, heights[4]=2: 2<6, 弹出栈顶
  - height=6, st=[1,2], width=4-2-1=1, area=6×1=6
  - 2<5, 弹出栈顶
  - height=5, st=[1], width=4-1-1=2, area=5×2=10
  - st=[1,4]
i=5, heights[5]=3: st=[1,4], 直接入栈, st=[1,4,5]
i=6, heights[6]=0: 0<3, 弹出栈顶
  - height=3, st=[1,4], width=6-4-1=1, area=3×1=3
  - 0<2, 弹出栈顶
  - height=2, st=[1], width=6-1-1=4, area=2×4=8
  - 0<1, 弹出栈顶
  - height=1, st=[], width=6-(-1)-1=6, area=1×6=6
  - st=[]

最大面积：10
```

### 与双遍历法的对比

| 特性 | 双遍历法 | 单遍历优化法 |
|------|----------|--------------|
| 遍历次数 | 2次 | 1次 |
| 额外空间 | O(n) | O(1) |
| 哨兵技巧 | 不需要 | 需要 |
| 代码复杂度 | 较简单 | 较复杂 |
| 性能 | 稍慢 | 稍快 |

### 双遍历法（普通版本）使用 `>=`

```cpp
while (!st.empty() && heights[st.top()] >= heights[i]) {
    st.pop();
}
```

#### 为什么使用 `>=`：

1. **找第一个严格小于的元素**：
   - 对于每个柱子，我们要找左边第一个**严格小于**它的柱子
   - 如果遇到相等的柱子，应该继续弹出，因为相等的柱子不能作为边界

2. **避免重复计算**：
   - 如果两个相邻柱子高度相等，以它们为高度的矩形面积是相同的
   - 使用 `>=` 确保只保留最右边的相等元素

3. **边界定义**：
   - 左边界：左边第一个严格小于当前柱子的位置
   - 右边界：右边第一个严格小于当前柱子的位置

### 单遍历法（优化版本）使用 `>`

```cpp
while (!st.empty() && heights[st.top()] > heights[i]) {
    // 计算面积
}
```

#### 为什么使用 `>`：

1. **直接计算面积**：
   - 当遇到更小的柱子时，栈中所有大于该柱子的元素都可以确定右边界
   - 相等的柱子不应该被弹出，因为它们可能还有机会形成更大的矩形

2. **避免过早计算**：
   - 如果弹出相等的柱子，可能会错过以该柱子为高度的更大矩形
   - 相等的柱子应该保留在栈中，等待后续处理

### 具体例子说明

假设有数组 `[2, 2, 2, 1]`：

#### 双遍历法（使用 `>=`）：
```
i=0: heights[0]=2, st=[], left[0]=-1, st=[0]
i=1: heights[1]=2, 2>=2, 弹出0, st=[], left[1]=-1, st=[1]
i=2: heights[2]=2, 2>=2, 弹出1, st=[], left[2]=-1, st=[2]
i=3: heights[3]=1, 1<2, left[3]=2, st=[2,3]
```

#### 单遍历法（使用 `>`）：
```
i=0: heights[0]=2, st=[], 直接入栈, st=[0]
i=1: heights[1]=2, 2=2, 不弹出, st=[0,1]
i=2: heights[2]=2, 2=2, 不弹出, st=[0,1,2]
i=3: heights[3]=1, 1<2, 弹出所有大于1的元素
  - height=2, width=3-(-1)-1=3, area=6
  - height=2, width=3-(-1)-1=3, area=6
  - height=2, width=3-(-1)-1=3, area=6
```

### 总结

- **双遍历法用 `>=`**：因为我们要找严格小于的边界，相等的元素不能作为边界
- **单遍历法用 `>`**：因为我们要在遇到更小元素时才计算面积，相等的元素应该保留等待后续处理

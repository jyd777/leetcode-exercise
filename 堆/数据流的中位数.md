# 数据流的中位数

**中位数**是有序整数列表中的中间值。如果列表的大小是偶数，则没有中间值，中位数是两个中间值的平均值。

- 例如 `arr = [2,3,4]` 的中位数是 `3` 。
- 例如 `arr = [2,3]` 的中位数是 `(2 + 3) / 2 = 2.5` 。

实现 MedianFinder 类:

- `MedianFinder() `初始化 `MedianFinder` 对象。
- `void addNum(int num)` 将数据流中的整数 `num` 添加到数据结构中。
- `double findMedian()` 返回到目前为止所有元素的中位数。与实际答案相差 `10-5` 以内的答案将被接受。

**示例 1：**

```
输入
["MedianFinder", "addNum", "addNum", "findMedian", "addNum", "findMedian"]
[[], [1], [2], [], [3], []]
输出
[null, null, null, 1.5, null, 2.0]

解释
MedianFinder medianFinder = new MedianFinder();
medianFinder.addNum(1);    // arr = [1]
medianFinder.addNum(2);    // arr = [1, 2]
medianFinder.findMedian(); // 返回 1.5 ((1 + 2) / 2)
medianFinder.addNum(3);    // arr[1, 2, 3]
medianFinder.findMedian(); // return 2.0
```

**提示:**

- `-105 <= num <= 105`
- 在调用 `findMedian` 之前，数据结构中至少有一个元素
- 最多 `5 * 104` 次调用 `addNum` 和 `findMedian`

## 双堆解法

使用两个堆来维护数据流的

中位数：

1. **最大堆（左半部分）**：存储较小的数，堆顶是左半部分的最大值
2. **最小堆（右半部分）**：存储较大的数，堆顶是右半部分的最小值
3. **平衡策略**：保持两个堆的大小相等或左堆比右堆多1个元素

```cpp
class MedianFinder {
public:
    // 最大堆，存储左半部分（较小的数），堆顶是左半部分的最大值
    priority_queue<int> maxHeap;
    // 最小堆，存储右半部分（较大的数），堆顶是右半部分的最小值
    priority_queue<int, vector<int>, greater<int>> minHeap;
    // 保证左右两个堆元素个数相等或者左堆比右堆多一个元素
    MedianFinder() {
        
    }
    
    void addNum(int num) {
        // 先加入最大堆
        maxHeap.push(num);
        // 将最大堆的堆顶元素移到最小堆
        minHeap.push(maxHeap.top());
        maxHeap.pop();
        // 平衡两个堆的大小
        // 如果最小堆比最大堆大，则将最小堆的堆顶移回最大堆
        // 不能只通过判断maxHeap.size()>minHeap.size()+1来决定要不要平衡两个堆，因为这样会导致最大值在左半部分，而不是在右半部分（例如[1,2,3]，就会导致左半部分是[1,3]，右半部分是[2]）
        if (minHeap.size() > maxHeap.size()) {
            maxHeap.push(minHeap.top());
            minHeap.pop();
        }
    }
    
    double findMedian() {
        // 判断是奇数还是偶数（通过两个堆大小）
        if(maxHeap.size() > minHeap.size())
            return maxHeap.top();
        else
            return(maxHeap.top()+minHeap.top())/2.0;
    }
};

/**
 * Your MedianFinder object will be instantiated and called as such:
 * MedianFinder* obj = new MedianFinder();
 * obj->addNum(num);
 * double param_2 = obj->findMedian();
 */
```

**时间复杂度分析：**
- addNum：O(log n)
- findMedian：O(1)

**空间复杂度：** O(n)

**思路解释：**
- 使用两个堆将数据分为两部分
- 最大堆存储左半部分（较小的数）
- 最小堆存储右半部分（较大的数）
- 通过平衡策略确保中位数始终在正确位置
- 奇数个元素时，中位数在最大堆顶
- 偶数个元素时，中位数是两个堆顶的平均值
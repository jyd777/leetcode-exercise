# 滑动窗口最大值

给你一个整数数组 `nums`，有一个大小为 `k` 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 `k` 个数字。滑动窗口每次只向右移动一位。

返回 *滑动窗口中的最大值* 。

 

**示例 1：**

```
输入：nums = [1,3,-1,-3,5,3,6,7], k = 3
输出：[3,3,5,5,6,7]
解释：
滑动窗口的位置                最大值
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
```

**示例 2：**

```
输入：nums = [1], k = 1
输出：[1]
```

 

**提示：**

- `1 <= nums.length <= 105`
- `-104 <= nums[i] <= 104`
- `1 <= k <= nums.length`



**思想：单调队列法**

**核心思想**

- 用一个双端队列（deque），队列里存的是下标，并且保证队列里的数在窗口内、且对应的值从大到小单调递减。

- 队首永远是当前窗口的最大值的下标。

**操作流程**

1. 窗口右移一格，新元素下标为 i。
2. 队尾出队：如果队尾的元素比新元素小或等于，说明它永远不会成为窗口最大值，可以弹出。
3. 新元素入队：把新元素下标加到队尾。
4. 队首出队：如果队首的下标已经滑出窗口（i - k），就弹出队首。
5. 记录最大值：当窗口形成（i >= k-1），队首就是当前窗口最大值的下标。

```C++
class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        vector<int> res;
        deque<int> dq;// 最大值候选队列，同时也是单调递减队列：队首永远是窗口最大值的下标
        for(int i=0;i<nums.size();i++){
            // 当前要进来的是nums[i]
            // 在nums[i]存在于滑动窗口的时期中，当前队列中值小于nums[i]的永远不可能成为滑动窗口中的最大值，所以我们可以将这些值从dq中排除
            // 由于dq为单调递减队列，所以从队尾开始删除
            while(!dq.empty() && nums[i]>= nums[dq.back()])
                dq.pop_back();
            // 更新窗口右边界，放入下标i
            dq.push_back(i);
            // 更新窗口左边界
            if (dq.front() <= i-k)
                dq.pop_front();
            // 得到当前滑动窗口中的最大值
            if(i+1>=k)
                res.push_back(nums[dq.front()]);
        }
        return res;
    }
};
```

